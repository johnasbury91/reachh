---
phase: 03-enhanced-detection
plan: 03
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - dolphin/sources/proxies/__init__.py
  - dolphin/sources/proxies/base.py
  - dolphin/sources/proxies/decodo.py
  - dolphin/sources/proxies/brightdata.py
  - dolphin/sources/proxy_health.py
autonomous: true

must_haves:
  truths:
    - "Script works with Decodo proxy URLs"
    - "Script works with Bright Data proxy URLs"
    - "Unknown proxy formats are handled gracefully (not crash)"
    - "Proxy provider is auto-detected from URL hostname"
  artifacts:
    - path: "dolphin/sources/proxies/base.py"
      provides: "ProxyProvider Protocol definition"
      contains: "class ProxyProvider"
    - path: "dolphin/sources/proxies/decodo.py"
      provides: "Decodo provider implementation"
      exports: ["DecodoProvider"]
    - path: "dolphin/sources/proxies/brightdata.py"
      provides: "Bright Data provider implementation"
      exports: ["BrightDataProvider"]
    - path: "dolphin/sources/proxies/__init__.py"
      provides: "Provider registry and auto-detection"
      exports: ["get_provider", "PROVIDERS"]
  key_links:
    - from: "dolphin/sources/proxies/__init__.py"
      to: "dolphin/sources/proxies/decodo.py"
      via: "import and register"
      pattern: "DecodoProvider"
    - from: "dolphin/sources/proxies/__init__.py"
      to: "dolphin/sources/proxies/brightdata.py"
      via: "import and register"
      pattern: "BrightDataProvider"
    - from: "dolphin/sources/proxy_health.py"
      to: "dolphin/sources/proxies"
      via: "import get_provider for URL normalization"
      pattern: "from.*proxies.*import"
---

<objective>
Abstract proxy handling into multi-provider architecture.

Purpose: Different proxy providers (Decodo, Bright Data, Oxylabs) have slightly different URL formats and features. A provider abstraction allows easy addition of new providers and consistent URL handling.

Output: ProxyProvider Protocol with Decodo and Bright Data implementations, plus registry for auto-detection from proxy URLs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-enhanced-detection/03-RESEARCH.md
@.planning/phases/03-enhanced-detection/03-02-SUMMARY.md
@dolphin/sources/proxy_health.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create proxies package with Protocol and registry</name>
  <files>
    dolphin/sources/proxies/__init__.py
    dolphin/sources/proxies/base.py
  </files>
  <action>
Create `dolphin/sources/proxies/` directory structure.

**base.py** - Define ProxyProvider Protocol:
```python
"""
Base protocol for proxy providers.
Uses typing.Protocol for structural typing (no inheritance needed).
"""

from dataclasses import dataclass
from typing import Protocol, runtime_checkable


@dataclass
class ProxyConfig:
    """Normalized proxy configuration."""
    url: str  # Full URL: scheme://user:pass@host:port
    provider: str  # Provider name (e.g., "decodo", "brightdata")
    original_url: str  # Original URL before normalization


@runtime_checkable
class ProxyProvider(Protocol):
    """Interface for proxy providers."""

    @property
    def name(self) -> str:
        """Provider identifier (e.g., 'decodo', 'brightdata')."""
        ...

    def matches(self, proxy_url: str) -> bool:
        """Check if this provider handles the given proxy URL."""
        ...

    def normalize(self, proxy_url: str) -> ProxyConfig:
        """
        Normalize proxy URL and return ProxyConfig.

        Handles:
        - URL encoding of credentials (special chars in password)
        - Default scheme if missing
        - Provider-specific URL transformations
        """
        ...
```

**__init__.py** - Provider registry and auto-detection:
```python
"""
Proxy provider registry.
Auto-detects provider from URL and provides normalization.
"""

from dolphin.sources.proxies.base import ProxyConfig, ProxyProvider
from dolphin.sources.proxies.decodo import DecodoProvider
from dolphin.sources.proxies.brightdata import BrightDataProvider

# Registry of all providers
PROVIDERS: list[ProxyProvider] = [
    DecodoProvider(),
    BrightDataProvider(),
]


def get_provider(proxy_url: str) -> ProxyProvider | None:
    """
    Auto-detect provider from proxy URL.

    Returns:
        Matching provider, or None if no provider matches.
    """
    for provider in PROVIDERS:
        if provider.matches(proxy_url):
            return provider
    return None


def normalize_proxy(proxy_url: str) -> ProxyConfig | None:
    """
    Normalize proxy URL using appropriate provider.

    Returns:
        ProxyConfig with normalized URL, or None if unrecognized.
    """
    if not proxy_url or proxy_url == "None":
        return None

    provider = get_provider(proxy_url)
    if provider:
        return provider.normalize(proxy_url)

    # Fallback: return as-is with "unknown" provider
    return ProxyConfig(
        url=proxy_url,
        provider="unknown",
        original_url=proxy_url
    )
```
  </action>
  <verify>
1. Directory exists: `ls -d dolphin/sources/proxies`
2. Imports work: `cd dolphin && python -c "from sources.proxies import get_provider, PROVIDERS; print(f'{len(PROVIDERS)} providers')"`
3. Protocol defined: `grep -c "class ProxyProvider" dolphin/sources/proxies/base.py` returns 1
  </verify>
  <done>proxies package exists with ProxyProvider Protocol and registry functions</done>
</task>

<task type="auto">
  <name>Task 2: Implement Decodo and Bright Data providers</name>
  <files>
    dolphin/sources/proxies/decodo.py
    dolphin/sources/proxies/brightdata.py
  </files>
  <action>
**decodo.py** - Decodo (formerly Smartproxy) provider:
```python
"""Decodo proxy provider (formerly Smartproxy)."""

from urllib.parse import urlparse, quote, urlunparse

from dolphin.sources.proxies.base import ProxyConfig


class DecodoProvider:
    """Decodo/Smartproxy proxy provider."""

    @property
    def name(self) -> str:
        return "decodo"

    def matches(self, proxy_url: str) -> bool:
        """Match decodo.com or smartproxy.com domains."""
        lower = proxy_url.lower()
        return "decodo.com" in lower or "smartproxy.com" in lower

    def normalize(self, proxy_url: str) -> ProxyConfig:
        """Normalize Decodo proxy URL with encoded credentials."""
        return ProxyConfig(
            url=self._encode_credentials(proxy_url),
            provider=self.name,
            original_url=proxy_url,
        )

    def _encode_credentials(self, proxy_url: str) -> str:
        """URL-encode credentials in proxy URL."""
        parsed = urlparse(proxy_url)

        # Add default scheme if missing
        if not parsed.scheme:
            proxy_url = f"http://{proxy_url}"
            parsed = urlparse(proxy_url)

        # Encode username and password if present
        if parsed.username or parsed.password:
            username = quote(parsed.username or "", safe="")
            password = quote(parsed.password or "", safe="")
            netloc = f"{username}:{password}@{parsed.hostname}"
            if parsed.port:
                netloc += f":{parsed.port}"
            return urlunparse((
                parsed.scheme,
                netloc,
                parsed.path,
                parsed.params,
                parsed.query,
                parsed.fragment,
            ))

        return proxy_url
```

**brightdata.py** - Bright Data provider:
```python
"""Bright Data proxy provider."""

from urllib.parse import urlparse, quote, urlunparse

from dolphin.sources.proxies.base import ProxyConfig


class BrightDataProvider:
    """Bright Data (formerly Luminati) proxy provider."""

    @property
    def name(self) -> str:
        return "brightdata"

    def matches(self, proxy_url: str) -> bool:
        """Match brightdata.com or luminati.io domains."""
        lower = proxy_url.lower()
        return (
            "brightdata.com" in lower
            or "brd.superproxy.io" in lower
            or "luminati.io" in lower
        )

    def normalize(self, proxy_url: str) -> ProxyConfig:
        """Normalize Bright Data proxy URL with encoded credentials."""
        return ProxyConfig(
            url=self._encode_credentials(proxy_url),
            provider=self.name,
            original_url=proxy_url,
        )

    def _encode_credentials(self, proxy_url: str) -> str:
        """URL-encode credentials in proxy URL."""
        # Same logic as Decodo - factor out if needed later
        parsed = urlparse(proxy_url)

        if not parsed.scheme:
            proxy_url = f"http://{proxy_url}"
            parsed = urlparse(proxy_url)

        if parsed.username or parsed.password:
            username = quote(parsed.username or "", safe="")
            password = quote(parsed.password or "", safe="")
            netloc = f"{username}:{password}@{parsed.hostname}"
            if parsed.port:
                netloc += f":{parsed.port}"
            return urlunparse((
                parsed.scheme,
                netloc,
                parsed.path,
                parsed.params,
                parsed.query,
                parsed.fragment,
            ))

        return proxy_url
```

Note: Both providers share similar credential encoding logic. This is intentional - keep them separate for now, factor out only if a third provider is added (avoid premature abstraction).
  </action>
  <verify>
1. Decodo provider: `cd dolphin && python -c "from sources.proxies.decodo import DecodoProvider; p = DecodoProvider(); print(p.matches('http://user:pass@gate.decodo.com:7000'))"`
2. Bright Data provider: `cd dolphin && python -c "from sources.proxies.brightdata import BrightDataProvider; p = BrightDataProvider(); print(p.matches('http://user:pass@brd.superproxy.io:22225'))"`
3. Auto-detection: `cd dolphin && python -c "from sources.proxies import get_provider; p = get_provider('http://x@gate.decodo.com:7000'); print(p.name if p else 'none')"`
  </verify>
  <done>DecodoProvider and BrightDataProvider implementations with URL matching and credential encoding</done>
</task>

<task type="auto">
  <name>Task 3: Integrate providers with ProxyHealthChecker</name>
  <files>dolphin/sources/proxy_health.py</files>
  <action>
Update ProxyHealthChecker to use provider normalization:

1. **Import provider functions:**
```python
from dolphin.sources.proxies import normalize_proxy
```

2. **Update check() method** to use normalized URL:
```python
async def check(self, proxy_url: str, timeout: float = 10.0) -> ProxyHealth:
    """Test if proxy can reach Reddit."""

    # Handle no-proxy case
    if not proxy_url or proxy_url == "None":
        return ProxyHealth(status="N/A")

    # Normalize URL using provider (handles credential encoding)
    config = normalize_proxy(proxy_url)
    normalized_url = config.url if config else proxy_url

    # ... rest of implementation uses normalized_url
```

This ensures:
- Credentials with special characters are properly encoded
- Unknown providers still work (fallback to original URL)
- Provider-specific transformations are applied
  </action>
  <verify>
1. Import works: `cd dolphin && python -c "from sources.proxy_health import ProxyHealthChecker; print('ok')"`
2. Uses normalize: `grep -c "normalize_proxy" dolphin/sources/proxy_health.py` returns >= 1
  </verify>
  <done>ProxyHealthChecker uses provider abstraction for URL normalization</done>
</task>

</tasks>

<verification>
1. Package structure: `ls dolphin/sources/proxies/*.py` shows __init__.py, base.py, decodo.py, brightdata.py
2. Provider count: `cd dolphin && python -c "from sources.proxies import PROVIDERS; print(len(PROVIDERS))"` returns 2
3. Decodo matching: `cd dolphin && python -c "from sources.proxies import get_provider; print(get_provider('http://x@gate.decodo.com:7000').name)"` returns "decodo"
4. Bright Data matching: `cd dolphin && python -c "from sources.proxies import get_provider; print(get_provider('http://x@brd.superproxy.io:22225').name)"` returns "brightdata"
5. Unknown handled: `cd dolphin && python -c "from sources.proxies import normalize_proxy; c = normalize_proxy('http://x@unknown.com:8080'); print(c.provider)"` returns "unknown"
6. Integration: `grep -c "normalize_proxy" dolphin/sources/proxy_health.py` returns >= 1
</verification>

<success_criteria>
1. ProxyProvider Protocol defined with name, matches(), normalize() methods
2. DecodoProvider handles decodo.com and smartproxy.com URLs
3. BrightDataProvider handles brightdata.com, brd.superproxy.io, luminati.io URLs
4. Provider registry auto-detects provider from URL
5. Unknown proxy URLs handled gracefully (fallback to "unknown" provider)
6. ProxyHealthChecker uses normalize_proxy() for credential encoding
</success_criteria>

<output>
After completion, create `.planning/phases/03-enhanced-detection/03-03-SUMMARY.md`
</output>

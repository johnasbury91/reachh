---
phase: 06-data-hygiene-reliability
plan: 03
type: execute
wave: 2
depends_on:
  - 06-02
files_modified:
  - dolphin/sheets_sync.py
  - dolphin/tracker.py
autonomous: true

must_haves:
  truths:
    - "Profiles deleted from Dolphin are moved to Archive tab (not left stale)"
    - "Archive tab has same columns as main sheet plus archive_reason and archived_at"
    - "Stale profiles detected by comparing sheet profile_ids vs Dolphin profile_ids"
  artifacts:
    - path: "dolphin/sheets_sync.py"
      provides: "archive_stale_profiles function"
      contains: "archive_stale_profiles"
    - path: "dolphin/sheets_sync.py"
      provides: "Archive worksheet creation"
      contains: "worksheet(\"Archive\")"
  key_links:
    - from: "dolphin/tracker.py"
      to: "dolphin/sheets_sync.py"
      via: "archive_stale_profiles call"
      pattern: "archive_stale_profiles"
---

<objective>
Detect and archive profiles that have been deleted from Dolphin Anty.

Purpose: Profiles deleted from Dolphin should be moved to an Archive tab rather than left as stale rows in the main sheet. This keeps the main sheet clean while preserving history.

Output: Archive tab with archived profiles, stale detection during sync.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-data-hygiene-reliability/06-RESEARCH.md

# Existing sync module
@dolphin/sheets_sync.py
@dolphin/tracker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add archive functions to sheets_sync.py</name>
  <files>dolphin/sheets_sync.py</files>
  <action>
Add archive infrastructure to sheets_sync.py.

1. Add ARCHIVE_HEADERS constant:
   ```python
   # Archive tab has main headers + archive metadata
   ARCHIVE_HEADERS = HEADERS + ["archive_reason", "archived_at"]
   ```

2. Add helper function `_get_or_create_archive_sheet`:
   ```python
   def _get_or_create_archive_sheet(spreadsheet: gspread.Spreadsheet) -> gspread.Worksheet:
       """Get or create the Archive worksheet."""
       try:
           archive_sheet = spreadsheet.worksheet("Archive")
       except gspread.WorksheetNotFound:
           # Create with enough rows/cols for archived data
           archive_sheet = spreadsheet.add_worksheet(
               title="Archive",
               rows=1000,
               cols=len(ARCHIVE_HEADERS),
           )
           # Write headers
           archive_sheet.update(f"A1:{chr(64 + len(ARCHIVE_HEADERS))}1", [ARCHIVE_HEADERS])
       return archive_sheet
   ```

3. Add `archive_stale_profiles` function:
   ```python
   def archive_stale_profiles(
       dolphin_profile_ids: set[str],
   ) -> dict:
       """
       Archive profiles that exist in sheet but not in Dolphin.

       Args:
           dolphin_profile_ids: Set of profile IDs currently in Dolphin

       Returns:
           dict with "archived" count
       """
   ```

   Implementation:
   a. Connect to Google Sheets (same pattern as sync_to_sheet)
   b. Get all values from main sheet (row 3 onwards, skip header and summary)
   c. Find rows where profile_id (column A) is NOT in dolphin_profile_ids
   d. For each stale row:
      - Append to Archive sheet with archive_reason="deleted_from_dolphin" and archived_at=now
   e. Delete stale rows from main sheet (use delete_rows, work backwards to preserve indices)
   f. Return {"archived": count}

Important:
- Use batch append_rows for archive (single API call)
- Delete rows in reverse order to avoid index shifting issues
- Profile ID is in column A (index 0)
- Skip SUMMARY row (profile_id == "SUMMARY")
  </action>
  <verify>python3 -c "from dolphin.sheets_sync import archive_stale_profiles; print('Import OK')"</verify>
  <done>archive_stale_profiles function exists and imports successfully</done>
</task>

<task type="auto">
  <name>Task 2: Integrate stale detection into tracker</name>
  <files>dolphin/tracker.py</files>
  <action>
Add stale profile archival to the tracker run.

1. Add import:
   ```python
   from sheets_sync import sync_to_sheet, archive_stale_profiles
   ```

2. After profiles are fetched from Dolphin (after `profiles = await dolphin.get_profiles()`), extract profile IDs:
   ```python
   dolphin_profile_ids = {str(p.id) for p in profiles}
   ```

3. After sync_to_sheet completes successfully, call archive_stale_profiles:
   ```python
   # Sync to Google Sheets
   try:
       logger.info("Syncing to Google Sheets...")
       stats = sync_to_sheet(results)
       logger.info(f"Sheets sync complete: {stats['updated']} updated, {stats['inserted']} inserted")

       # Archive profiles deleted from Dolphin
       archive_stats = archive_stale_profiles(dolphin_profile_ids)
       if archive_stats["archived"] > 0:
           logger.info(f"Archived {archive_stats['archived']} stale profile(s)")
   except Exception as e:
       logger.warning(f"Sheets sync failed: {e}")
   ```

This ensures stale detection runs every time the tracker syncs to sheets.
  </action>
  <verify>grep -q "archive_stale_profiles" dolphin/tracker.py</verify>
  <done>tracker.py calls archive_stale_profiles after sync_to_sheet</done>
</task>

</tasks>

<verification>
1. `python3 -c "from dolphin.sheets_sync import archive_stale_profiles, ARCHIVE_HEADERS"` - imports work
2. `grep -q "deleted_from_dolphin" dolphin/sheets_sync.py` - archive reason present
3. `grep -q "archive_stale_profiles" dolphin/tracker.py` - integration exists
4. `grep -q 'worksheet("Archive")' dolphin/sheets_sync.py` - archive sheet reference
</verification>

<success_criteria>
- archive_stale_profiles function detects profiles in sheet not in Dolphin
- Stale profiles are appended to Archive tab with reason and timestamp
- Stale profiles are removed from main sheet
- Archive tab created automatically if it doesn't exist
- Archive tab has 15 columns (13 main + archive_reason + archived_at)
- Tracker logs number of archived profiles
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-hygiene-reliability/06-03-SUMMARY.md`
</output>
